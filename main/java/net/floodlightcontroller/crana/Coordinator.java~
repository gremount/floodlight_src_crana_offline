package net.floodlightcontroller.crana;


import java.io.*;
import java.util.Collection;
import java.util.EnumSet;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Random;
import java.util.concurrent.Executors;  
import java.util.concurrent.ScheduledExecutorService;   

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.projectfloodlight.openflow.protocol.OFFlowMod;
import org.projectfloodlight.openflow.protocol.OFFlowModFlags;
import org.projectfloodlight.openflow.protocol.OFType;
import org.projectfloodlight.openflow.protocol.action.OFAction;
import org.projectfloodlight.openflow.protocol.action.OFActionOutput;
import org.projectfloodlight.openflow.protocol.match.Match;
import org.projectfloodlight.openflow.protocol.match.MatchField;
import org.projectfloodlight.openflow.types.DatapathId;
import org.projectfloodlight.openflow.types.EthType;
import org.projectfloodlight.openflow.types.MacAddress;
import org.projectfloodlight.openflow.types.OFBufferId;
import org.projectfloodlight.openflow.types.OFPort;
import org.projectfloodlight.openflow.types.OFVlanVidMatch;
import org.projectfloodlight.openflow.types.TransportPort;
import org.projectfloodlight.openflow.types.U64;
import org.projectfloodlight.openflow.types.VlanVid;
import org.projectfloodlight.openflow.types.IPv4Address;
import org.projectfloodlight.openflow.types.IPv6Address;
import org.projectfloodlight.openflow.types.IpProtocol;

import net.floodlightcontroller.core.FloodlightContext;
import net.floodlightcontroller.core.IFloodlightProviderService;
import net.floodlightcontroller.core.IOFSwitch;
import net.floodlightcontroller.core.internal.IOFSwitchService;
import net.floodlightcontroller.core.module.FloodlightModuleContext;
import net.floodlightcontroller.core.module.FloodlightModuleException;
import net.floodlightcontroller.core.module.IFloodlightModule;
import net.floodlightcontroller.core.module.IFloodlightService;
import net.floodlightcontroller.core.util.AppCookie;
import net.floodlightcontroller.linkdiscovery.ILinkDiscovery.LDUpdate;
import net.floodlightcontroller.packet.Ethernet;
import net.floodlightcontroller.packet.IPv4;
import net.floodlightcontroller.packet.IPv6;
import net.floodlightcontroller.packet.TCP;
import net.floodlightcontroller.packet.UDP;
import net.floodlightcontroller.routing.Link;
import net.floodlightcontroller.routing.Route;
import net.floodlightcontroller.sflowcollector.ISflowListener;
import net.floodlightcontroller.sflowcollector.InterfaceStatistics;
import net.floodlightcontroller.threadpool.IThreadPoolService;
import net.floodlightcontroller.threadpool.ThreadPool;
import net.floodlightcontroller.topology.ITopologyListener;
import net.floodlightcontroller.topology.ITopologyService;
import net.floodlightcontroller.topology.NodePortTuple;
import net.floodlightcontroller.util.FlowModUtils;
import net.floodlightcontroller.util.MatchUtils;
import net.floodlightcontroller.util.OFDPAUtils;
import net.floodlightcontroller.util.OFMessageDamper;
import net.floodlightcontroller.sflowcollector.ISflowCollectionService;
import net.floodlightcontroller.crana.Edge;
import net.floodlightcontroller.crana.Demand;
import net.floodlightcontroller.crana.SrcDstTuple;

import net.floodlightcontroller.crana.selfishrouting.*;
import net.floodlightcontroller.crana.trafficengineering.*;
import net.floodlightcontroller.crana.cheat_off.Cheating;
import net.floodlightcontroller.crana.cheat_on.Cheating_on;

public class Coordinator implements IFloodlightModule, ITopologyListener, ISflowListener{
	private static final Logger log = LoggerFactory.getLogger(Coordinator.class);
	private static boolean isEnabled = false;
	private static final String ENABLED_STR = "enable";
	
	protected static String ROUTING_CHOICE = "TE";
	protected static int OFMESSAGE_DAMPER_CAPACITY = 10000; // TODO: find sweet spot
	protected static int OFMESSAGE_DAMPER_TIMEOUT = 250; // ms
	public static final int FLOW_DURATION = 10;
	public static final int INITIAL_DEALY = 20;
	public static final int PERIOD = 400;
	public static final int BG_DEMAND_NUM = 20; 
	public static final int APP_DEMAND_NUM = 15; 
	public static Random rand;

	protected static boolean FLOWMOD_DEFAULT_MATCH_TRANSPORT = true;
	public static int FLOWMOD_DEFAULT_IDLE_TIMEOUT = 300; // in seconds
	public static int FLOWMOD_DEFAULT_HARD_TIMEOUT = 310; // infinite
	public static int FLOWMOD_DEFAULT_PRIORITY = 233; // 0 is the default table-miss flow in OF1.3+, so we need to use 1
	public static final int MAX_DEMAND = 20; 
	public static final int DEMAND_NUM = 30; 
	public static final int Coordinator_APP_ID = 3; 
	static {
		AppCookie.registerApp(Coordinator_APP_ID, "Coordinator");
	}
	public static final U64 appCookie = AppCookie.makeCookie(Coordinator_APP_ID, 0);
	
	private static IThreadPoolService threadPoolService;
	private static ITopologyService topologyService;
	private static ISflowCollectionService sflowCollectionService;
	private static IOFSwitchService switchService;
	private OFMessageDamper messageDamper;
	
	private static ScheduledFuture<?> test;
	
	private int numDpid;
	private int numEdge;
	private static Set<Link>  allLinks;
	private static Map<NodePortTuple,InterfaceStatistics > statisticsMap;
	private static List<Edge> incL;
	static ArrayList<Demand> req;
	public ArrayList<Integer> appver;// Overlay vertex
	public static long topoTS = 0;
	
	//after computing route
	public void PushAllRoute(){
		Map<Integer, List<Integer>> paths = readPath("data/path.txt");
		
		for(Demand dm : req){
			DatapathId srcDpid = DatapathId.of(dm.getSrc() + 1);
			OFPort sPort = dm.getSp();
			DatapathId dstDpid = DatapathId.of(dm.getDst() + 1);
			OFPort dPort = dm.getDp();
			//System.out.println("********demand is coming*******");
			//System.out.println("demand " + dm.getId() +  ": " +srcDpid + " -> " + dstDpid);
			
			List<Integer> path = paths.get(dm.getId());
			
			Route route = getRoute(path, srcDpid, sPort, dstDpid, dPort);
			
			pushBiRoute(route, dm.getSrc(), dm.getDst(), dm.getTcpSrcPort(), dm.getTcpDstPort());
		    
		}
	}
	
	protected Match createMatch(int src, int dst, int tsp, int tdp) {
		DatapathId srcDpid = DatapathId.of(src + 1);
		//DatapathId dstDpid = DatapathId.of(dst + 1);
		
		IOFSwitch srcMac = switchService.getSwitch(srcDpid);
		//IOFSwitch dstMac = switchService.getSwitch(dstDpid);
		
		Match.Builder mb = srcMac.getOFFactory().buildMatch();
		
		IPv4Address sip = IPv4Address.of(167772160 + src + 1);
		IPv4Address dip = IPv4Address.of(167772160 + dst + 1);
	    
		TransportPort udpSrcPort = TransportPort.of(tsp);
		TransportPort udpDstPort = TransportPort.of(tdp);
		
		boolean MATCH_UDP_PORT = false;
		if(MATCH_UDP_PORT){
			mb.setExact(MatchField.ETH_TYPE, EthType.IPv4)
			.setExact(MatchField.IPV4_SRC, sip)
			.setExact(MatchField.IPV4_DST, dip)
			.setExact(MatchField.IP_PROTO, IpProtocol.UDP)
			.setExact(MatchField.UDP_SRC, udpSrcPort)
			.setExact(MatchField.UDP_DST, udpDstPort);
		}else{
			mb.setExact(MatchField.ETH_TYPE, EthType.IPv4)
			.setExact(MatchField.IPV4_SRC, sip)
			.setExact(MatchField.IPV4_DST, dip);
		}
		
		return mb.build();
	}
	
	public void pushBiRoute(Route route, int src, int dst, int tsp, int tdp){
		List<NodePortTuple> switchPortList = route.getPath();
		List<NodePortTuple> reSwitchPortList = new ArrayList<>();
		
		for(int i = switchPortList.size() - 1; i >= 0; i--){
			reSwitchPortList.add(switchPortList.get(i));
		}
		
		//System.out.println("push forward route");
		Match match = createMatch(src, dst, tsp, tdp);
		pushRoute(switchPortList, match);
		
		//System.out.println("push reverse route");
		Match reMatch = createMatch(dst, src, tdp, tsp);
		pushRoute(reSwitchPortList, reMatch);
		
		
	}
	
	public void pushRoute(List<NodePortTuple> switchPortList , Match match) {
		
		for (int indx = switchPortList.size() - 1; indx > 0; indx -= 2) {
			// indx and indx-1 will always have the same switch DPID.
			DatapathId switchDPID = switchPortList.get(indx).getNodeId();
			IOFSwitch sw = switchService.getSwitch(switchDPID);

			if (sw == null) {
				System.out.println("sw is null");
				return;
			}
			
			// need to build flow mod based on what type it is. Cannot set command later
			OFFlowMod.Builder fmb = sw.getOFFactory().buildFlowAdd();
			
			OFActionOutput.Builder aob = sw.getOFFactory().actions().buildOutput();
			List<OFAction> actions = new ArrayList<OFAction>();	
			
			Match.Builder mb = MatchUtils.convertToVersion(match, sw.getOFFactory().getVersion());
 			
			// set input and output ports on the switch
			OFPort outPort = switchPortList.get(indx).getPortId();
			OFPort inPort = switchPortList.get(indx - 1).getPortId();
			
			mb.setExact(MatchField.IN_PORT, inPort);
			
			aob.setPort(outPort);
			aob.setMaxLen(Integer.MAX_VALUE);
			actions.add(aob.build());
			
			//requestFlowRemovedNotification
			Set<OFFlowModFlags> flags = new HashSet<>();
			flags.add(OFFlowModFlags.SEND_FLOW_REM);
			fmb.setFlags(flags);
		    
			//U64 cookie = U64.of(0);
			U64 cookie = AppCookie.makeCookie(Coordinator_APP_ID, 0);
			
			fmb.setMatch(mb.build())
			.setIdleTimeout(FLOWMOD_DEFAULT_IDLE_TIMEOUT)
			.setHardTimeout(FLOWMOD_DEFAULT_HARD_TIMEOUT)
			.setBufferId(OFBufferId.NO_BUFFER)
			.setCookie(cookie)
			.setOutPort(outPort)
			.setPriority(FLOWMOD_DEFAULT_PRIORITY);
			
			FlowModUtils.setActions(fmb, actions, sw);
			
			
			try {				
				
				messageDamper.write(sw, fmb.build());
				/*
				log.info("Pushing Route flowmod routeIndx={} \n               " +
						"sw={}  srcIp = {} dstIp = {} inPort={} outPort={} ",
						new Object[] {indx,
						sw,
						fmb.getMatch().get(MatchField.IPV4_SRC),
						fmb.getMatch().get(MatchField.IPV4_DST),
						fmb.getMatch().get(MatchField.IN_PORT),
						outPort });
				*/

			} catch (IOException e) {
				log.error("Failure writing flow mod", e);
			}
		}
	}
	
	//convert a path to route
	public Route getRoute(List<Integer> path, DatapathId srcId, OFPort srcPort, DatapathId dstId, OFPort dstPort) {
		Route route = new Route(srcId, dstId);
		List<NodePortTuple> switchPorts = new ArrayList<>();
		switchPorts.add(new NodePortTuple(srcId,srcPort));
		if(path !=null)
			for(Integer id : path){
				if(incL!=null && (incL.size() -1 ) >= id ){
					switchPorts.add(incL.get(id).srcPort);
					switchPorts.add(incL.get(id).dstPort);
				}
		}
		switchPorts.add(new NodePortTuple(dstId,dstPort));
		
		route.setPath(switchPorts);	
		
		return route;
	}
	
	//read path computed by our algorithm
	public Map<Integer, List<Integer>> readPath(String filename){
		File file = new File(filename);
		if(!file.exists())
			System.out.println("path file doesn't exist.");
		
		Map<Integer, List<Integer>> paths = new HashMap<Integer, List<Integer>>();
		
		try{
			Scanner input = new Scanner(file);
			while(input.hasNext()){
				String line = input.nextLine();
				String [] strAry = line.split(" ");
				Integer id  = Integer.parseInt(strAry[0]);
				List<Integer> path = new ArrayList<>();
			    for (int i = 1; i < strAry.length; i++)
			    	path.add(Integer.parseInt(strAry[i]));
			    if(paths.get(id) == null)
			    	paths.put(id, path);
			}
			
			input.close();
		}
		catch(IOException e){
			System.out.println(e);
		}
		return paths;
	}
	
	// called when topo changed or sflow get new statistics
	public void updateTopo() {
		
		File file = new File("data/topo.txt");
		try{
			PrintWriter output = new PrintWriter(file);
			incL.clear();
			int id = 0;
			output.println(numDpid);
		
			if(allLinks != null)
				for(Link lk: allLinks)
					if(lk != null){
						if(statisticsMap != null
							&& statisticsMap.containsKey(new NodePortTuple(lk.getSrc(),lk.getSrcPort()))
							&& statisticsMap.get(new NodePortTuple(lk.getSrc(),lk.getSrcPort()))!=null){	
							Edge edge = new Edge(id++, lk, statisticsMap.get(new NodePortTuple(lk.getSrc(),lk.getSrcPort())).getIfOutOctets().doubleValue());
							output.println(edge.printEdge());
							incL.add(edge);
                        }else{
                        	Edge edge = new Edge(id++, lk, 0);
                        	output.println(edge.printEdge());
                        	incL.add(edge);	
                        }
						
				    }
			     
		output.close();
		}
		catch(IOException e){
			System.out.println(e);
		}
	}
	
	/** generate topology for Overlay or server selection  
	 * @param n:Â∏åÊúõ‰∫ßÁîüÁöÑoverlayÈ°∂ÁÇπÊï∞
	 * @param mÔºöÂ∏åÊúõ‰∫ßÁîüÁöÑoverlayËæπÊï∞
	 * @throws IOException
	 */
	public void ModifiedTopo(int n,int m) throws IOException{
		if(n<=0||m<=0){	
			System.err.println("Error : in ModifiedTopo param n and m must be positive,please check param");		
		}
		for(int i = 0;i<n;i++){
			appver.add(rand.nextInt(this.numDpid)+1);
		}
		
		File file = new File("data\\GraphOR.txt");
		BufferedWriter out = new BufferedWriter(new FileWriter(file, false));

		out.write(n + " " + m);
		out.newLine();
			
		for (int k = 1; k < appver.size(); k++) {
			int t = rand.nextInt(k), cap = rand.nextInt(50), weight = rand.nextInt(10) + 1;
			out.write(appver.get(k) + " " + appver.get(t) + " " + weight + " " + cap);
			out.newLine();
			out.write(appver.get(t) + " " + appver.get(k) + " " + weight + " " + cap);
			out.newLine();
		}
		
		for (int i = 0; i < m - n + 1; i++) {
			int s = rand.nextInt(n), t = rand.nextInt(n), cap = rand.nextInt(50), weight = rand.nextInt(10) + 1;
			while (t == s)
				t = rand.nextInt(n);
			
			out.write(appver.get(s) + " " + appver.get(t) + " " + weight + " " + cap);
			out.newLine();
			out.write(appver.get(t) + " " + appver.get(s) + " " + weight + " " + cap);
			out.newLine();
		}
		out.close();
	}
	

	/**
	 * ÂäüËÉΩÔºö‰∫ßÁîüËÉåÊôØÊµÅÂíåappÊµÅ
	 */
	public void GenerateDemand() throws IOException{
		int numDem = rand.nextInt(numDpid*(numDpid-1)/2) + 1;
		int numAppDem = rand.nextInt(numDem) + 1;
		req.clear();
		GenDemand(numDpid,numDem,"data/req.txt", "data/gt.txt");// Ê†πÊçÆÂõæÁöÑÁÇπÊï∞‰∫ßÁîüdemnum‰∏™ËÉåÊôØÊµÅÈúÄÊ±Ç
		//GenAppDemand(numAppDem,"data/appreq.txt"); //‰∫ßÁîüAPP ÊµÅÈúÄÊ±Ç
	
		//renameFile("inputFile\\req.txt","inputFile\\reqold.txt"); //ÈáçÂëΩÂêç
		//ReadDemand("inputFile\\req.txt");// ËØªÂÖ•ÊµÅÈáèÁü©Èòµ
	}
	
	/**
	 * ÂäüËÉΩÔºö‰∫ßÁîüÊï¥‰∏™ÁΩëÁªúÁöÑËÉåÊôØÊµÅ
	 * ÔºÅÔºÅÔºÅattentionÔºÅÔºÅÔºÅÔºÅÔºöhostÂíå‰∫§Êç¢Êú∫‰πãÈó¥ÁöÑÂÖ•Á´ØÂè£Âè∑ ÔºåÂÅáÂÆöÂú®1-5Âè∑‰πãÈó¥ÔºåÂú®ÊûÑÂª∫mininetÁΩëÁªúÊó∂Ôºå‰∫§Êç¢Êú∫‰πãÈó¥ÁöÑÁ´ØÂè£Âè∑‰∏çËÉΩ‰∏∫1-5‰πãÈó¥
	 * @param n ÔºöÁÇπÊï∞
	 * @param num :ÈúÄÊ±ÇÊï∞
	 * @param name :Êñá‰ª∂Âêç
	 * @throws IOException
	 */
	public  void GenDemand(int numDpid,int numDem, String reqName, String trName) throws IOException {
		File reqFile = new File(reqName);
		File trFile = new File(trName);
		PrintWriter outReq = new PrintWriter(reqFile);
		PrintWriter outTr = new PrintWriter(trFile);

		outReq.println(numDem);
	    
		int k = 0;
		for (int i = 0; i < numDpid; i++)
			for(int j = i+1;  j < numDpid ; j++)
			{
				int flow = 409600;
				Demand dem = new Demand(k  , i, j, flow);
				req.add(dem);			
				outReq.println(dem.printDem());
				outTr.print(genTraffic(k++, i, j, flow));
			}
		
		/*
		for (int i = 0; i < numDem; i++) {
			int s = rand.nextInt(numDpid), t;
			do{
				t=rand.nextInt(numDpid);
			}while(s==t);
			//int flow = rand.nextInt(15)+2;
			int flow = 409600;
			Demand dem = new Demand(i, s, t, flow);
			req.add(dem);			
			outReq.println(dem.printDem());
			outTr.print(genTraffic( i, s, t, flow));
		}
		*/
		outReq.close();
		outTr.close();
	}
	
	public String genTraffic(int i, int s, int t, int flow){
		return "time x h" + (t+1) + " xterm -title d" + i + "_h" + (t+1) + "_recv -e ITGRecv\n"
				+ "py time.sleep(0.1)\n"
				+ "time x h" + (s+1) + " xterm -title d" + i + "_h" + (s+1) + "_send -e ITGSend -a 10.0.0." + (t+1) + " -T UDP -t 5000\n"
				+ "py time.sleep(0.1)\n";
	}
	/**
	 * ÂäüËÉΩÔºö‰∫ßÁîüAPPÊµÅÈúÄÊ±Ç
	 * @param num:ÈúÄÊ±ÇÊï∞
	 * @param name:Êñá‰ª∂Âêç
	 * @throws IOException
	 */
	public void GenAppDemand(int num,String name) throws IOException {
		File file = new File(name);
		BufferedWriter out = new BufferedWriter(new FileWriter(file,false));
		out.write("" + num);
		out.newLine();	
		int index = appver.size();
		for(int i = 0;i < num;i++){
			int s = rand.nextInt(index),t;
			do{
				t=rand.nextInt(index);
			}while(s==t);
			int sp = rand.nextInt(5)+1;//ÈúÄÊ±Ç,switchÂÖ•Á´ØÂè£Âè∑
			int dp = rand.nextInt(5)+1;
			int flow = rand.nextInt(15)+2;
			int tcpsp =rand.nextInt(100)+9000;// TCP source port
			int tcpdp =rand.nextInt(100)+9000;
			Demand dem = new Demand(i, appver.get(s),OFPort.of(sp), appver.get(t),OFPort.of(dp),tcpsp,tcpdp,flow*1.0);
			req.add(dem);			
			out.write(dem.printDem());	
			out.newLine();
			out.flush();		
		}
		out.close();
	}
	
	public void renameFile(String file, String toFile) {

        File toBeRenamed = new File(file);
        //Ê£ÄÊü•Ë¶ÅÈáçÂëΩÂêçÁöÑÊñá‰ª∂ÊòØÂê¶Â≠òÂú®ÔºåÊòØÂê¶ÊòØÊñá‰ª∂
        if (!toBeRenamed.exists() || toBeRenamed.isDirectory()) {

            System.err.println("File does not exist: " + file);
            return;
        }

        File newFile = new File(toFile);

        //‰øÆÊîπÊñá‰ª∂Âêç
        if (toBeRenamed.renameTo(newFile)) {
            System.out.println("File has been renamed.");
        } else {
            System.err.println("Error renmaing file");
        }

    }
	public void ReadDemand(String name) {
		File file = new File(name);
		BufferedReader reader = null;
		if (file.isFile() && file.exists()) {
			try {
				reader = new BufferedReader(new FileReader(file));
				String ss = null;
				int id = 0;
				int demnum = Integer.parseInt(reader.readLine());
				while ((ss = reader.readLine()) != null) {
					String[] tmp = ss.split(" ");
					int src = Integer.parseInt(tmp[0]), dst = Integer.parseInt(tmp[1]);
					int sp = Integer.parseInt(tmp[2]), dp = Integer.parseInt(tmp[3]);
					int tcpsp = Integer.parseInt(tmp[5]), tcpdp = Integer.parseInt(tmp[6]);
					int flow = Integer.parseInt(tmp[7]);
					Demand dem = new Demand(id, src, OFPort.of(sp), dst,OFPort.of(dp), tcpsp, tcpdp, flow);
				}

				reader.close();
			} catch (IOException e) {
				System.err.println("File Error!");
			} finally {
				if (reader != null) {
					try {
						reader.close();
					} catch (IOException e1) {
					}
				}
			}
		} else {
			System.err.println("can not find flie req.txt ");
		}
	}
	
	@Override
	public void sflowCollected(Map<Integer, InterfaceStatistics> ifIndexIfStatMap){
		statisticsMap = sflowCollectionService.getStatisticsMap();
		updateTopo();
		System.out.println("*********** sflow get new statistics: print all Edge **********");
		//System.out.println(incL);
		
	}

	//get all links.
	@Override
	public void topologyChanged(List<LDUpdate> linkUpdates) {
		long cur = System.currentTimeMillis();
		if(topoTS == 0){
			System.out.print("first update");
			topoTS = cur;
		}else{
			long interval = (cur - topoTS);
			System.out.print("topo update interval " + interval + " ms");
			topoTS = cur;
		}
		Map<DatapathId, Set<Link>>  dpidLinks = topologyService.getAllLinks();
		Set<DatapathId> dpidSet = dpidLinks.keySet();
		allLinks.clear();
		if(dpidSet.size() != 0)
			numDpid = dpidSet.size();
	
		System.out.println(", this time has " + numDpid + " sw");
		
		if(dpidSet != null){
			for(DatapathId dpid : dpidSet){
				Set<Link> linkSet = dpidLinks.get(dpid);
				if (linkSet == null) continue;
				//System.out.println(i++ + " " + dpid.toString() +  " : " + linkSet);
				allLinks.addAll(linkSet);
			}
		}
		numEdge = allLinks.size();
		
		updateTopo();
		
		//System.out.println("************* topologyChanged: print all links ***********");
		//System.out.println(allLinks);
	}
	
	@Override
	public Collection<Class<? extends IFloodlightService>> getModuleServices() {
		return null;
	}

	@Override
	public Map<Class<? extends IFloodlightService>, IFloodlightService> getServiceImpls() {
		Map<Class<? extends IFloodlightService>, IFloodlightService> m =
				new HashMap<Class<? extends IFloodlightService>, IFloodlightService>();
		return m;
	}

	@Override
	public Collection<Class<? extends IFloodlightService>> getModuleDependencies() {
		Collection<Class<? extends IFloodlightService>> l =
				new ArrayList<Class<? extends IFloodlightService>>();
		l.add(ITopologyService.class);
		l.add(ISflowCollectionService.class);
		l.add(IThreadPoolService.class);
		return l;
	}

	@Override
	public void init(FloodlightModuleContext context) throws FloodlightModuleException {
		topologyService  = context.getServiceImpl(ITopologyService.class);
		sflowCollectionService = context.getServiceImpl(ISflowCollectionService.class);
		switchService = context.getServiceImpl(IOFSwitchService.class);
		//threadPoolService = context.getServiceImpl(IThreadPoolService.class);
		
		messageDamper = new OFMessageDamper(OFMESSAGE_DAMPER_CAPACITY,
				EnumSet.of(OFType.FLOW_MOD),
				OFMESSAGE_DAMPER_TIMEOUT);
		
		allLinks = new HashSet<Link>();
		incL = new ArrayList<Edge>();
		req = new ArrayList<Demand>();
		rand = new Random(System.currentTimeMillis());
		
		Map<String, String> config = context.getConfigParams(this);
		if (config.containsKey(ENABLED_STR)) {
			try {
				isEnabled = Boolean.parseBoolean(config.get(ENABLED_STR).trim());
			} catch (Exception e) {
				log.error("Could not parse '{}'. Using default of {}", ENABLED_STR, isEnabled);
			}
		}
		log.info("Coordinator {}", isEnabled ? "enabled" : "disabled");
	}

	@Override
	public void startUp(FloodlightModuleContext context) throws FloodlightModuleException {
		if (isEnabled) {
			topologyService.addListener(this); 
			sflowCollectionService.addSflowListener(this);
			log.info("\n*****Coordinator starts*****");
			Runnable test = new TestTask();
			ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();  
			service.scheduleAtFixedRate(test, INITIAL_DEALY, PERIOD, TimeUnit.SECONDS); 
		}
	}
	
	class TestTask implements Runnable{
    	public void run(){
    		
    		int exitid = 1;
    		try{
    			GenerateDemand();
    			
    			long t0 = System.currentTimeMillis();
    			
    			switch(ROUTING_CHOICE){
    				case "SR": 
    					exitid = SelfishRouting.callSR();
    					break;
    				case "TE":
    					exitid = TrafficEngineering.callTE();
    					break;
    				case "Cheating":
    					exitid = Cheating.callCheat();
    					break;
    				case "Cheating_java":
    					exitid = Compute.computeRoute(); 
    				    break;			
    				default:
    					System.out.println("No this routing service. Stay tuned.");
    			}
    			
    			long consuming = System.currentTimeMillis() - t0;
    			
    			if(exitid == 0)
    				System.out.println("routing success, takes " + consuming + " ms" );
    			else{
    				System.out.println("routing failed.");
    				return;
    			}
    		}
    		catch(Exception e){
    			e.printStackTrace();
    			return;
    		}
    		System.out.println("read path");
    		PushAllRoute();
    		System.out.println("1Ô∏è‚É£2Ô∏è‚É£3Ô∏è‚É£üéâüéâüéâ\nüëâIt's time to generate traffic.üíïüíïüíï");
        }
    	
    }

}
